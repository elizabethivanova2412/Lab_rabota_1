# Тема: Указатели в языке C

## Задача 1 - Упражнения с malloc
**Постановка задачи**  
Внутри функции int main(void) { /*...*/ } определите указатель:
double **pointer = NULL;

Инициализируйте этот указатель адресом другого указателя типа double **, который указывает, в свою очередь, на переменную double. Используйте pointer для записи и чтения в эту переменную значения 2.

При этом выполните следующее: - Используйте функции типа *alloc(...) для выделения оперативной памяти под динамические объекты; - Запишите и выведите число 2 на экран, используя указатель double ***pointer = NULL; - Используйте функцию free(...) для освобождения оперативной памяти, выделенной под динамические объекты. - Не используйте никаких идентификаторов переменных, кроме pointer.

**Математическая модель**  
Трехуровневая косвенная адресация через указатели: pointer → *pointer → **pointer → значение типа double.

**Список идентификаторов**
| Имя переменной | Тип данных | Описание |
|----------------|------------|----------|
| p | double*** | Трехуровневый указатель |

**Код программы**
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    double ***p = NULL;
    
    p = malloc(sizeof(double**));
    *p = malloc(sizeof(double*));
    **p = malloc(sizeof(double));
    
    ***p = 7.5;
    printf("%.1f\n", ***p);
    
    free(**p);
    free(*p);
    free(p);
    
    return 0;
}
```

**Результат выполнения**

![Решение задачи 1](https://raw.githubusercontent.com/elizabethivanova2412/Lab_1_Ivanova_Elizaveta/main/1_%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0.png)
```
```

## Задача 2 - Итерация массива с арифметикой указателей
**Постановка задачи**  
Напишите программу, которая создает одномерный динамический массив из чисел с плавающей точкой двойной точности, заполняет его значениями с клавиатуры и выводит все элементы массива, используя арифметику указателей (оператор +), а не оператор доступа к элементам массива [ ].

**Математическая модель**  
Использование адресной арифметики для доступа к элементам массива: *(arr + i) ≡ arr[i]

**Список идентификаторов**
| Имя переменной | Тип данных | Описание |
|----------------|------------|----------|
| n | int | Размер массива |
| a | double* | Указатель на массив |
| p | double* | Текущий указатель при обходе |

**Код программы**
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n;
    printf("Размер массива: ");
    scanf("%d", &n);
    
    double *a = malloc(n * sizeof(double));
    
    printf("Введите элементы:\n");
    for (double *p = a; p < a + n; p++) {
        scanf("%lf", p);
    }
    
    printf("Массив: ");
    for (double *p = a; p < a + n; p++) {
        printf("%.1f ", *p);
    }
    printf("\n");
    
    free(a);
    return 0;
}
```

**Результат выполнения**
```
![Решение задачи 2](https://raw.githubusercontent.com/elizabethivanova2412/Lab_1_Ivanova_Elizaveta/main/2_%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0.png)

```

---

## Задача 3 - Динамический 2D массив
**Постановка задачи**  
Выделите память под двумерный динамический массив двумя способами:
1. **Классический способ**: выделите память для массива указателей на строки и отдельно для каждой строки в цикле.
2. **Непрерывный способ**: выделите память для всего массива одним вызовом malloc, что позволит разместить весь массив в непрерывном блоке памяти, улучшая производительность и снижая риск внешней фрагментации памяти.
После выполнения программы обязательно корректно освободите всю выделенную оперативную память с помощью
free().
Оба метода имеют свои преимущества и недостатки. При непрерывном выделении (contiguous allocation) вся память
выделяется в одном блоке, что уменьшает вероятность фрагментации, но может усложнить управление при необходимости изменения размеров массива.

**Математическая модель**  
1. Массив указателей + массивы строк
2. Единый блок памяти размером rows × cols

**Список идентификаторов**
| Имя переменной | Тип данных | Описание |
|----------------|------------|----------|
| r | int | Количество строк |
| c | int | Количество столбцов |
| m1 | int** | Массив указателей на строки (способ 1) |
| m2 | int* | Единый блок памяти (способ 2) |
| i | int | Счётчик строк |
| j | int | Счётчик столбцов |

**Код программы**
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int r = 2, c = 3;
    
    int **m1 = malloc(r * sizeof(int*));
    for (int i = 0; i < r; i++) {
        m1[i] = malloc(c * sizeof(int));
        for (int j = 0; j < c; j++) {
            m1[i][j] = (i + 1) * (j + 1);
        }
    }
    
    printf("Способ 1:\n");
    for (int i = 0; i < r; i++) {
        for (int j = 0; j < c; j++) {
            printf("%2d ", m1[i][j]);
        }
        printf("\n");
    }
    
    for (int i = 0; i < r; i++) free(m1[i]);
    free(m1);
    
    printf("\n");
    
    int *m2 = malloc(r * c * sizeof(int));
    
    for (int i = 0; i < r; i++) {
        for (int j = 0; j < c; j++) {
            m2[i * c + j] = (i + 2) * (j + 2);
        }
    }
    
    printf("Способ 2:\n");
    for (int i = 0; i < r; i++) {
        for (int j = 0; j < c; j++) {
            printf("%2d ", m2[i * c + j]);
        }
        printf("\n");
    }
    
    free(m2);
    
    return 0;
}
```

**Результат выполнения**
```
Способ 1:
 1  2  3 
 2  4  6 

Способ 2:
 4  6  8 
 6  9 12
```

---

## Задача 4 - Поменять местами два числа
**Постановка задачи**  
Написать программу, которая использует функцию для обмена значениями двух переменных через указатели.

**Математическая модель**  
swap(a, b): temp = *a; *a = *b; *b = temp

**Список идентификаторов**
| Имя переменной | Тип данных | Описание |
|----------------|------------|----------|
| sw | функция | Функция обмена значений |
| x, y | int* | Указатели на обмениваемые переменные |
| t | int | Временная переменная для обмена |
| a, b | int | Исходные переменные |

**Код программы**
```c
#include <stdio.h>

void sw(int *x, int *y) {
    int t = *x;
    *x = *y;
    *y = t;
}

int main() {
    int a = 15, b = 25;
    printf("До обмена: %d и %d\n", a, b);
    sw(&a, &b);
    printf("После обмена: %d и %d\n", a, b);
    return 0;
}
```

**Результат выполнения**
```
До обмена: 15 и 25
После обмена: 25 и 15
```

---

## Задача 5 - Поиск максимального элемента
**Постановка задачи**  
Создать функцию, которая принимает массив целых чисел и его размер, а затем возвращает указатель на максимальный элемент массива.

**Математическая модель**  
max = arr[0]; for(i=1..n-1) if(arr[i] > *max) max = &arr[i]

**Список идентификаторов**
| Имя переменной | Тип данных | Описание |
|----------------|------------|----------|
| max | функция | Поиск максимального элемента |
| a | int* | Указатель на массив |
| n | int | Размер массива |
| m | int* | Указатель на текущий максимум |
| p | int* | Текущий указатель при обходе |

**Код программы**
```c
#include <stdio.h>

int* max(int *a, int n) {
    int *m = a;
    for (int *p = a + 1; p < a + n; p++) {
        if (*p > *m) m = p;
    }
    return m;
}

int main() {
    int a[] = {12, 45, 23, 67, 34, 89};
    int n = sizeof(a) / sizeof(a[0]);
    
    int *m = max(a, n);
    printf("Максимальный элемент: %d\n", *m);
    
    return 0;
}
```

**Результат выполнения**
```
Максимальный элемент: 89
```

---

## Задача 6 - Реверс массива
**Постановка задачи**  
Реализовать функцию, которая переворачивает массив целых чисел, используя указатели для перемещения по элементам.

**Математическая модель**  
i = 0; j = n-1; while(i < j) swap(&arr[i], &arr[j]); i++; j--;

**Список идентификаторов**
| Имя переменной | Тип данных | Описание |
|----------------|------------|----------|
| rev | функция | Реверс массива |
| a | int* | Указатель на массив |
| n | int | Размер массива |
| s | int* | Указатель на начало |
| e | int* | Указатель на конец |
| t | int | Временная переменная |

**Код программы**
```c
#include <stdio.h>

void rev(int *a, int n) {
    int *s = a;
    int *e = a + n - 1;
    
    while (s < e) {
        int t = *s;
        *s = *e;
        *e = t;
        s++;
        e--;
    }
}

int main() {
    int a[] = {10, 20, 30, 40, 50, 60};
    int n = sizeof(a) / sizeof(a[0]);
    
    printf("Исходный: ");
    for (int i = 0; i < n; i++) printf("%d ", a[i]);
    
    rev(a, n);
    
    printf("\nПеревернутый: ");
    for (int i = 0; i < n; i++) printf("%d ", a[i]);
    
    return 0;
}
```

**Результат выполнения**
```
Исходный: 10 20 30 40 50 60
Перевернутый: 60 50 40 30 20 10
```

---

## Задача 7 - Поиск подстроки
**Постановка задачи**  
Реализовать функцию, которая находит первое вхождение одной строки в другую, используя указатели вместо индексов для доступа к символам строки.

**Математическая модель**  
Поиск шаблона в строке: для каждой позиции i проверяем совпадение символов s[i..i+m-1] с f[0..m-1]

**Список идентификаторов**
| Имя переменной | Тип данных | Описание |
|----------------|------------|----------|
| find | функция | Поиск подстроки |
| s | char* | Исходная строка |
| f | char* | Искомая подстрока |
| start | char* | Начальная позиция поиска |
| p, q | char* | Указатели для сравнения символов |

**Код программы**
```c
#include <stdio.h>

char* find(char *s, char *f) {
    char *p, *q, *start;
    
    for (start = s; *start; start++) {
        p = start;
        q = f;
        
        while (*q && *p == *q) {
            p++;
            q++;
        }
        
        if (!*q) return start;
    }
    
    return NULL;
}

int main() {
    char s[] = "Programming in C language";
    char f[] = "in C";
    
    char *r = find(s, f);
    
    if (r) printf("Подстрока найдена: позиция %ld\n", r - s);
    else printf("Подстрока не найдена\n");
    
    return 0;
}
```

**Результат выполнения**
```
Подстрока найдена: позиция 12
```

---

## Задача 8 - Копирование строки
**Постановка задачи**  
Написать функцию, которая копирует одну строку в другую, используя указатели вместо встроенной функции strcpy.

**Математическая модель**  
while(*src != '\0') { *dest = *src; dest++; src++; } *dest = '\0';

**Список идентификаторов**
| Имя переменной | Тип данных | Описание |
|----------------|------------|----------|
| copy | функция | Копирование строки |
| d | char* | Указатель на строку-назначение |
| s | char* | Указатель на исходную строку |

**Код программы**
```c
#include <stdio.h>

void copy(char *d, char *s) {
    while (*s) {
        *d = *s;
        d++;
        s++;
    }
    *d = '\0';
}

int main() {
    char s[] = "C Programming";
    char d[50];
    
    copy(d, s);
    printf("Результат: %s\n", d);
    
    return 0;
}
```

**Результат выполнения**
```
Результат: C Programming
```

---

## Задача 9 - Подсчет пробелов
**Постановка задачи**  
Написать функцию, которая подсчитывает количество пробелов в строке, используя указатели для перемещения по символам строки.

**Математическая модель**  
count = 0; for(i=0..len-1) if(str[i] == ' ') count++;

**Список идентификаторов**
| Имя переменной | Тип данных | Описание |
|----------------|------------|----------|
| spaces | функция | Подсчёт пробелов |
| s | char* | Указатель на строку |
| c | int | Счётчик пробелов |

**Код программы**
```c
#include <stdio.h>

int spaces(char *s) {
    int c = 0;
    while (*s) {
        if (*s == ' ') c++;
        s++;
    }
    return c;
}

int main() {
    char s[] = "Count spaces in this text";
    
    printf("Строка: \"%s\"\n", s);
    printf("Количество пробелов: %d\n", spaces(s));
    
    return 0;
}
```

**Результат выполнения**
```
Строка: "Count spaces in this text"
Количество пробелов: 4
```

---

## Задача 10 - Указатель на функцию
**Постановка задачи**  
Реализуйте функцию сортировки одномерного массива, которая принимает указатель на функцию сравнения. Эта функция сравнения должна определять порядок сортировки — по возрастанию или по убыванию.

**Математическая модель**  
Пузырьковая сортировка с пользовательской функцией сравнения

**Список идентификаторов**
| Имя переменной | Тип данных | Описание |
|----------------|------------|----------|
| sort | функция | Сортировка массива |
| sw | функция | Обмен элементов |
| up | функция | Сравнение для сортировки по возрастанию |
| down | функция | Сравнение для сортировки по убыванию |
| cmp | указатель | Указатель на функцию сравнения |
| a | int* | Указатель на массив |
| n | int | Размер массива |

**Код программы**
```c
#include <stdio.h>

void sw(int *x, int *y) {
    int t = *x;
    *x = *y;
    *y = t;
}

int up(int a, int b) {
    return a > b;
}

int down(int a, int b) {
    return a < b;
}

void sort(int *a, int n, int (*cmp)(int, int)) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (cmp(*(a + j), *(a + j + 1))) {
                sw(a + j, a + j + 1);
            }
        }
    }
}

int main() {
    int a[] = {15, 7, 22, 4, 18, 9, 12};
    int n = sizeof(a) / sizeof(a[0]);
    
    printf("Исходный: ");
    for (int i = 0; i < n; i++) printf("%d ", a[i]);
    
    sort(a, n, up);
    printf("\nПо возрастанию: ");
    for (int i = 0; i < n; i++) printf("%d ", a[i]);
    
    sort(a, n, down);
    printf("\nПо убыванию: ");
    for (int i = 0; i < n; i++) printf("%d ", a[i]);
    printf("\n");
    
    return 0;
}
```

**Результат выполнения**
```
Исходный: 15 7 22 4 18 9 12
По возрастанию: 4 7 9 12 15 18 22
По убыванию: 22 18 15 12 9 7 4
```

# Данные о студенте
```
Иванова Елизавета, 1 курс, ПОО
```
